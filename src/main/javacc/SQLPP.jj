/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  static = false;}PARSER_BEGIN(SQLPP)package edu.uci.ics.asterix.sqlpp.parser;

public class SQLPP {
    public static void main(String[] args) throws Exception {
        SQLPPExp result = new SQLPP(new java.io.StringReader(args[0])).S();
        System.out.println(result);
    }
}


// Classes defining the Abstract Syntax Tree
abstract class SQLPPExp {}
class SQLPPNumberValue extends SQLPPExp {
    int value;
    SQLPPNumberValue(int v) {value = v;}
    public String toString() {return this.getClass().toString() + value + "";}
}
class BinarySQLPPExp extends SQLPPExp {
    String op;
    SQLPPExp left, right;
    BinarySQLPPExp(String o, SQLPPExp l, SQLPPExp r) {op = o; left = l; right = r;}
    public String toString() {return "(" + op + " " + left + " " + right + ")";}
}

PARSER_END(SQLPP)

SKIP:  { " " | "\t" | "\n" | "\r"                    }
TOKEN: { 
	"(" | ")" | "+" | "*" | <NUM: (["0"-"9"])+> | 
	";"
}

SQLPPExp S(): {SQLPPExp e;}
{
  e=E() <EOF> {return e;}
}

SQLPPExp E(): {SQLPPExp e1; SQLPPExp e2;}
{
  e1=T() ("+" e2=T() {e1 = new BinarySQLPPExp("+", e1, e2);} )* {return e1;}
}

SQLPPExp T(): {SQLPPExp e1; SQLPPExp e2;}
{
  e1=F() ("*" e2=F() {e1 = new BinarySQLPPExp("*", e1, e2);} )* {return e1;}
}

SQLPPExp F(): {SQLPPExp e; Token n;}
{
  n=<NUM> {return new SQLPPNumberValue(Integer.parseInt(n.image));}
|
  "(" e=E() ")" {return e;}
}