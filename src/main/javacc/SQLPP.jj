/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 * 
 */
options {
    STATIC = false;
    IGNORE_CASE = true;
}

/**
 * Parser
 */
 PARSER_BEGIN(SQLPP)
 package edu.uci.ics.asterix.sqlpp.parser;

import java.util.List;
import java.util.ArrayList;
import edu.uci.ics.asterix.sqlpp.base.AbstractStatement;
import edu.uci.ics.asterix.sqlpp.statement.SQLPPQuery;
import edu.uci.ics.asterix.sqlpp.base.AbstractExpression;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPOperatorExpr;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPUnaryExpr;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPUnaryExpr.Sign;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPSFWExpression;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPValueExpression;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPNamedValueExpression;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPSelectItemExpression;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPFromInnerJoin;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPFromOuterJoin;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPFromOuterJoin.OuterJoinType;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPFromItem;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPFromSingle;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPAliasExpression;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPVariableRef;
import edu.uci.ics.asterix.sqlpp.expression.Identifier;
import edu.uci.ics.asterix.sqlpp.base.AbstractValue;
import edu.uci.ics.asterix.sqlpp.value.DoubleValue;
import edu.uci.ics.asterix.sqlpp.value.FalseValue;
import edu.uci.ics.asterix.sqlpp.value.FloatValue;
import edu.uci.ics.asterix.sqlpp.value.IntegerValue;
import edu.uci.ics.asterix.sqlpp.value.LongValue;
import edu.uci.ics.asterix.sqlpp.value.MissingValue;
import edu.uci.ics.asterix.sqlpp.value.StringValue;
import edu.uci.ics.asterix.sqlpp.value.NullValue;
import edu.uci.ics.asterix.sqlpp.value.TrueValue;
import edu.uci.ics.asterix.sqlpp.parser.AbstractParser;
import edu.uci.ics.asterix.sqlpp.base.AbstractClause;
import edu.uci.ics.asterix.sqlpp.clause.SelectClause;
import edu.uci.ics.asterix.sqlpp.clause.FromClause;
import edu.uci.ics.asterix.sqlpp.clause.WhereClause;


public class SQLPP extends AbstractParser {
    public static void main(String[] args) throws Exception {
        List<AbstractStatement> result = new SQLPP(new java.io.StringReader(args[0])).Statements();
        for (AbstractStatement stmt : result) {
            SQLPPQuery q = (SQLPPQuery) stmt; 
            System.out.println(q);	
        }
    }
}
PARSER_END(SQLPP)


/**
 * Tokens
 */
<DEFAULT>
TOKEN :
{
  <SELECT : "select">
  | <FROM : "from">
  | <WHERE : "where">
  | <AS : "as">
  | <JOIN : "join">
  | <ON : "on">
  | <INNER : "inner">
  | <OUTER : "outer">
  | <LEFT : "left">
  | <RIGHT : "right">
  | <FULL : "full">
}

<DEFAULT>
TOKEN :
{
    <CARET : "^">
  | <DIV : "/">
  | <IDIV : "idiv">
  | <MINUS : "-">
  | <MOD : "%">
  | <MUL : "*">
  | <PLUS : "+">

  | <LEFTPAREN : "(">
  | <RIGHTPAREN : ")">
  | <LEFTBRACKET : "[">
  | <RIGHTBRACKET : "]">

  | <COLON : ":">
  | <COMMA : ",">
  | <DOT : ".">
  | <QUES : "?">

  | <LT : "<">
  | <GT : ">">
  | <LE : "<=">
  | <GE : ">=">
  | <EQ : "=">
  | <NE : "!=">
  | <SIMILAR : "~=">
  | <ASSIGN : ":=">

  | <AND : "and">
  | <OR : "or">
}

/**
 * Tuple value type not added yet.
 */
//<DEFAULT> 
//TOKEN :
//{
//    <LEFTBRACE : "{"> { pushState(); } : DEFAULT
//}
//
//<DEFAULT>
//TOKEN :
//{
//    <RIGHTBRACE : "}"> { popState("}"); }
//}

<DEFAULT>
TOKEN :
{
    <INTEGER_LITERAL : (<DIGIT>)+ >
}

<DEFAULT>
TOKEN :
{
    <NULL : "null">
  | <TRUE : "true">
  | <FALSE : "false">
  | <MISSING : "missing">
}

<DEFAULT>
TOKEN :
{
    <#DIGIT : ["0" - "9"]>
}

<DEFAULT>
TOKEN:
{
    < DOUBLE_LITERAL: <DIGITS>
        | <DIGITS> ( "." <DIGITS> )?
        | "." <DIGITS>
    >
  | < FLOAT_LITERAL: <DIGITS> ( "f" | "F" )
        | <DIGITS> ( "." <DIGITS> ( "f" | "F" ) )?
        | "." <DIGITS> ( "f" | "F" )
    >
  | <DIGITS : (<DIGIT>)+ >
}

<DEFAULT>
TOKEN :
{
    <#LETTER : ["A" - "Z", "a" - "z"]>
  | <SPECIALCHARS : ["$", "_", "-"]>
}

<DEFAULT>
TOKEN :
{
    // backslash u + 4 hex digits escapes are handled in the underlying JavaCharStream
    <STRING_LITERAL : ("\"" (
          <EscapeQuot>
        | <EscapeBslash>
        | <EscapeSlash>
        | <EscapeBspace>
        | <EscapeFormf>
        | <EscapeNl>
        | <EscapeCr>
        | <EscapeTab>
        | ~["\"","\\"])* "\"")
      | ("\'"(
          <EscapeApos>
        | <EscapeBslash>
        | <EscapeSlash>
        | <EscapeBspace>
        | <EscapeFormf>
        | <EscapeNl>
        | <EscapeCr>
        | <EscapeTab>
        | ~["\'","\\"])* "\'")>
  | < #EscapeQuot: "\\\"" >
  | < #EscapeApos: "\\\'" >
  | < #EscapeBslash: "\\\\" >
  | < #EscapeSlash: "\\/" >
  | < #EscapeBspace: "\\b" >
  | < #EscapeFormf: "\\f" >
  | < #EscapeNl: "\\n" >
  | < #EscapeCr: "\\r" >
  | < #EscapeTab: "\\t" >
}

<DEFAULT>
TOKEN :
{
    <IDENTIFIER : <LETTER> (<LETTER> | <DIGIT> | <SPECIALCHARS>)*>
}

<DEFAULT>
TOKEN :
{
    <VARIABLE : "$" <LETTER> (<LETTER> | <DIGIT> | "_")*>
}

<DEFAULT>
SKIP:
{
    " "
  | "\t"
  | "\r"
  | "\n"
}

<DEFAULT>
SKIP:
{
    <"//" (~["\n"])* "\n">
}

<DEFAULT>
SKIP:
{
    <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")?> 
}

  
/**
 * Comments are ignored, nothing about what is inside comments is done.
 */
//<DEFAULT>
//SKIP:
//{
//    <"/*"> { pushState(); } : INSIDE_COMMENT
//}
//
//<INSIDE_COMMENT> SPECIAL : {
//<"+" (" ")* (~["*"])*>
//}
//
//   
//<INSIDE_COMMENT> SKIP : {
//"/*" : {
//}
//
//   
//<INSIDE_COMMENT> SKIP : {
//"*/" : {
//| <~[]>
//}

/**
 * Rules
 */
//TODO: Fix the multiple statement initiation.
List<AbstractStatement> Statements() throws ParseException: {
	List<AbstractStatement> statements = new ArrayList<AbstractStatement>();
	AbstractStatement statement;
}
{
	( statement = SingleStatement() 
		{
			statements.add(statement);
		} (";") ?
	)*
	<EOF>
	{
		return statements;  
	}
}

AbstractStatement SingleStatement() throws ParseException: {
	AbstractStatement stmt;
} {
	stmt = Query() { return stmt; }
}

SQLPPQuery Query() throws ParseException: {
	SQLPPQuery q = new SQLPPQuery(); AbstractExpression e;
} {
	e = SQLPPExpression()
	{
		q.setBody(e);
		return q;
	}
}

AbstractExpression SQLPPExpression() throws ParseException: {
	AbstractExpression e;
} {
	( 
		e = SQLPPOperatorExpression()
		| e = SFWExpression()
	)
	{
		return e;
	}
} 

AbstractExpression SFWExpression() throws ParseException: {
	ArrayList<AbstractClause> clauses = new ArrayList<AbstractClause>();
	AbstractClause tmp;
} {
    tmp = Select()  {
    	clauses.add(tmp);
    }
    
    tmp = From() {
    	clauses.add(tmp);
    }
    (
    	tmp = Where() {
    		clauses.add(tmp);
    	}
    )?
   {
     return new SQLPPSFWExpression(clauses);
   }
}

AbstractClause Select() throws ParseException: {
	ArrayList<SQLPPSelectItemExpression> items = new ArrayList<SQLPPSelectItemExpression>();
	SQLPPSelectItemExpression expr1 = null;
	SQLPPSelectItemExpression expr2 = null;
} {
	<SELECT>
	expr1 = SelectItemExpr()
	(
		<COMMA>
		expr2 = SelectItemExpr()
		{
			items.add(expr2);
		}
	)*
	{
		items.add(0, expr1); //Adds expr1 at the begining of the list.
		return new SelectClause(items);
	}
}

SQLPPSelectItemExpression SelectItemExpr() throws ParseException: {
	SQLPPVariableRef var = null;
	AbstractExpression expr = null;
} {
	expr = ValueExpr()
	(
		<AS>
		var = VariableRef()
	)? {
		return new SQLPPSelectItemExpression(var, expr);
	}
}

SQLPPAliasExpression AliasExpression() throws ParseException: {
	Identifier ident = null;
} {
	ident = Identifier() {
		return new SQLPPAliasExpression(ident);
	}
}

AbstractClause From() throws ParseException: {
	ArrayList<SQLPPFromItem> items = new ArrayList<SQLPPFromItem>();
	SQLPPFromItem expr1 = null;
	SQLPPFromItem expr2 = null;
} {
	<FROM>
	expr1 = FromItem()
	(
		<COMMA>
		expr2 = FromItem()
		{
			items.add(expr2);
		}
	)*
	{
		items.add(0,expr1);
		return new FromClause(items);
	}	
}

SQLPPFromItem FromItem() throws ParseException: {
	SQLPPFromItem fromItem;
} {
	( fromItem = FromInnerJoin()
	| fromItem = FromOuterJoin()
	) {
		return fromItem;
	}
}

SQLPPFromSingle FromSingle() throws ParseException: {
	AbstractExpression expr = null;
	SQLPPVariableRef var = null;
} {
	expr = ValueExpr()
	(
		<AS>
		var = VariableRef()
	)? {
		return new SQLPPFromSingle(var, expr);
	}
}

SQLPPFromItem FromInnerJoin() throws ParseException: {
	SQLPPFromItem left = null;
	SQLPPFromItem right = null;
	AbstractExpression expr = null;
} {
	(<INNER>) ?
	left = FromSingle()
	( <JOIN>
	  right = FromItem()
	  <ON>
	  expr = SQLPPOperatorExpression()
	)? {
		if (right==null) { return left;}
		else {return new SQLPPFromInnerJoin(left, right, expr);}
	}
}

SQLPPFromItem FromOuterJoin() throws ParseException: {
	OuterJoinType joinType;
	SQLPPFromItem left = null;
	SQLPPFromItem right = null;
	AbstractExpression expr = null;
} {
	( <LEFT> { joinType = OuterJoinType.LEFT;}
	  | <RIGHT> { joinType = OuterJoinType.RIGHT;}
	  | <FULL> { joinType = OuterJoinType.FULL;}
	)
	<OUTER> 
	left = FromSingle()
	<JOIN>
	right = FromItem()
	<ON>
	expr = SQLPPOperatorExpression()
	{
		return new SQLPPFromOuterJoin(joinType, left, right, expr);
	}
}

SQLPPVariableRef VariableRef() throws ParseException: {
	Identifier ident = null;
} {
	ident = Identifier() {
		return new SQLPPVariableRef(ident);
	}
}

AbstractClause Where() throws ParseException: {
	AbstractExpression expr = null;
} {
	<WHERE>
	expr = SQLPPOperatorExpression()
	{
		return new WhereClause(expr);
	}
}

AbstractExpression SQLPPOperatorExpression() throws ParseException:
{
  SQLPPOperatorExpr op = null;
  AbstractExpression operand = null;
}
{
	operand = AndExpr()
	(
	  <OR>
  	{
  	  if (op == null) {
  	    op = new SQLPPOperatorExpr();
  	    op.addOperand(operand);      	     
  	  }  
      op.addOperator(token.image);
	}

	operand = AndExpr()
	{
	  op.addOperand(operand);
	}

	)*
	
	{
	  return op==null? operand: op;
	}
}

AbstractExpression AndExpr() throws ParseException:
{
  SQLPPOperatorExpr op = null;
  AbstractExpression operand = null;
}
{
	operand = RelExpr()
	(
	
	  <AND>
  	{
  	  if (op == null) {
  	    op = new SQLPPOperatorExpr();
  	    op.addOperand(operand);	      	     
  	  }  
      op.addOperator(token.image);
	}

	operand = RelExpr()
	{
	  op.addOperand(operand);
	}

	)*
	
	{
	  return op==null? operand: op;
	}
}



AbstractExpression RelExpr()throws ParseException:
{
  SQLPPOperatorExpr op = null;
  AbstractExpression operand = null;
}
{
    operand = AddExpr()

    (
      LOOKAHEAD(2)( <LT> | <GT> | <LE> | <GE> | <EQ> | <NE> |<SIMILAR>)
  	  {
  	    if (op == null) {
  	      op = new SQLPPOperatorExpr();
  	      op.addOperand(operand);
  	    }
        op.addOperator(token.image);
	  }
	  
 	  operand = AddExpr()
	  {
         op.addOperand(operand);
      } 
    )?
 	
 	{
 	  return op==null? operand: op;
 	}
}

/**
 * TODO: fix this problem.
 * Warning: Choice conflict in (...)* construct in this rule. Will need to be addressed.
         Expansion nested within construct and expansion following construct
         have common prefixes, one of which is: "+"
         Consider using a lookahead of 2 or more for nested expansion.
 */
AbstractExpression AddExpr() throws ParseException:
{
  SQLPPOperatorExpr op = null;
  AbstractExpression operand = null;  
}
{
	operand = MultExpr()

	( LOOKAHEAD(2)(<PLUS> | <MINUS>)
  	{
  	  if (op == null) {
  	    op = new SQLPPOperatorExpr();
        op.addOperand(operand);
  	  }
	  op.addOperator(token.image);
	}

	operand = MultExpr()
	{
	  op.addOperand(operand);
	}
	)*
	
	{
 	  return op==null? operand: op;
 	}
}

AbstractExpression MultExpr() throws ParseException:
{
  SQLPPOperatorExpr op = null;
  AbstractExpression operand = null;
}
{
	operand = UnaryExpr()

	(( <MUL> | <DIV> | <MOD> | <CARET> | <IDIV>)
  	{
  	  if (op == null) {
  	    op = new SQLPPOperatorExpr();
        op.addOperand(operand);          	    
  	  }
	  op.addOperator(token.image);
	}
	operand = UnaryExpr()
	{
	   op.addOperand(operand);
	}
	)*
	
 	{
 	  return op==null?operand:op;
 	}	
}

AbstractExpression UnaryExpr() throws ParseException:
{
	SQLPPUnaryExpr uexpr = null;
	AbstractExpression expr = null;
}
{
	( (<PLUS> | <MINUS>)
	{
	  	uexpr = new SQLPPUnaryExpr();
		if("+".equals(token.image))
			uexpr.setSign(Sign.POSITIVE);
		else if("-".equals(token.image))
			uexpr.setSign(Sign.NEGATIVE);
		else 
			throw new ParseException();
	}
	)?
	
	expr = ValueExpr()
	{
		if(uexpr!=null){
			uexpr.setExpr(expr);
			return uexpr;
		}
		else{
			return expr;
		}
	}
}

AbstractExpression ValueExpr() throws ParseException:
{
  AbstractExpression expr = null;
}
{
    ( expr = Value()
    | expr = NamedValue()
    )
    {
      return expr;
    }
}

AbstractExpression Value() throws ParseException:
{
  SQLPPValueExpression expr = new SQLPPValueExpression();
}
{
  (
	<STRING_LITERAL>
	{
	   expr.setValue(new StringValue(removeQuotesAndEscapes(token.image)));
	}
  |
	<INTEGER_LITERAL>
    {
    	try { 
    		expr.setValue(new IntegerValue(new Integer(token.image)));
    	} catch (NumberFormatException e) {
    		expr.setValue(new LongValue(new Long(token.image)));
    	}
    }
  | <FLOAT_LITERAL>
    {
    	expr.setValue(new FloatValue(new Integer(token.image)));
    }
  | <DOUBLE_LITERAL>
    {
    	expr.setValue(new DoubleValue(new Double(token.image)));
    }
  | <NULL>
    {
      	expr.setValue(new NullValue());
    }
  | <TRUE>
    {
	  	expr.setValue(new TrueValue());
    }      
  | <FALSE>
    {
      	expr.setValue(new FalseValue());
    }
  | <MISSING>
  	{
	  	expr.setValue(new MissingValue());
  	}
  )
    {
      return expr;
    }
}

/**
 * Named value rule
 */
AbstractExpression NamedValue() throws ParseException:
{
	Identifier ident = null;
}
{
	ident = Identifier()
	{
		return new SQLPPNamedValueExpression(ident);
	}
}

Identifier Identifier() throws ParseException: {}
{
	<IDENTIFIER>
	{
	   return new Identifier(token.image);
	}
}