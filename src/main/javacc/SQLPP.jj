/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 * 
 */
options {
    static = false;
}

/**
 * Parser
 */
 PARSER_BEGIN(SQLPP)
 package edu.uci.ics.asterix.sqlpp.parser;

import java.util.List;
import java.util.ArrayList;
import edu.uci.ics.asterix.sqlpp.base.AbstractStatement;
import edu.uci.ics.asterix.sqlpp.statement.SQLPPQuery;
import edu.uci.ics.asterix.sqlpp.base.AbstractExpression;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPOperatorExpr;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPUnaryExpr;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPUnaryExpr.Sign;
import edu.uci.ics.asterix.sqlpp.expression.SQLPPValueExpression;
import edu.uci.ics.asterix.sqlpp.base.AbstractValue;
import edu.uci.ics.asterix.sqlpp.value.DoubleValue;
import edu.uci.ics.asterix.sqlpp.value.FalseValue;
import edu.uci.ics.asterix.sqlpp.value.FloatValue;
import edu.uci.ics.asterix.sqlpp.value.IntegerValue;
import edu.uci.ics.asterix.sqlpp.value.LongValue;
import edu.uci.ics.asterix.sqlpp.value.MissingValue;
import edu.uci.ics.asterix.sqlpp.value.StringValue;
import edu.uci.ics.asterix.sqlpp.value.NullValue;
import edu.uci.ics.asterix.sqlpp.value.TrueValue;


public class SQLPP {
    public static void main(String[] args) throws Exception {
        List<AbstractStatement> result = new SQLPP(new java.io.StringReader(args[0])).Statements();
        for (AbstractStatement stmt : result) {
            SQLPPQuery q = (SQLPPQuery) stmt; 
            System.out.println(q);	
        }
    }
}
PARSER_END(SQLPP)


/**
 * Tokens
 */
<DEFAULT>
TOKEN :
{
    <ASC : "asc">
  | <AT : "at">
  | <BY : "by">
  | <DATASET : "dataset">
  | <DECOR : "decor">
  | <DESC : "desc">
  | <DISTINCT : "distinct">
  | <ELSE : "else">
  | <EVERY : "every">
  | <FOR : "for">
  | <GROUP : "group">
  | <IF : "if">
  | <IN : "in">
  | <LET : "let">
  | <LIMIT : "limit">
  | <OFFSET : "offset">
  | <ORDER : "order">
  | <RETURN : "return">
  | <SATISFIES : "satisfies">
  | <SOME : "some">
  | <THEN : "then">
  | <UNION : "union">
  | <WHERE : "where">
  | <WITH : "with">
}

<DEFAULT>
TOKEN :
{
    <CARET : "^">
  | <DIV : "/">
  | <IDIV : "idiv">
  | <MINUS : "-">
  | <MOD : "%">
  | <MUL : "*">
  | <PLUS : "+">

  | <LEFTPAREN : "(">
  | <RIGHTPAREN : ")">
  | <LEFTBRACKET : "[">
  | <RIGHTBRACKET : "]">

  | <COLON : ":">
  | <COMMA : ",">
  | <DOT : ".">
  | <QUES : "?">

  | <LT : "<">
  | <GT : ">">
  | <LE : "<=">
  | <GE : ">=">
  | <EQ : "=">
  | <NE : "!=">
  | <SIMILAR : "~=">
  | <ASSIGN : ":=">

  | <AND : "and">
  | <OR : "or">
}

//<DEFAULT> Tuple value type not added yet.
//TOKEN :
//{
//    <LEFTBRACE : "{"> { pushState(); } : DEFAULT
//}
//
//<DEFAULT>
//TOKEN :
//{
//    <RIGHTBRACE : "}"> { popState("}"); }
//}

<DEFAULT>
TOKEN :
{
    <INTEGER_LITERAL : (<DIGIT>)+ >
}

<DEFAULT>
TOKEN :
{
    <NULL : "null">
  | <TRUE : "true">
  | <FALSE : "false">
  | <MISSING : "missing">
}

<DEFAULT>
TOKEN :
{
    <#DIGIT : ["0" - "9"]>
}

<DEFAULT>
TOKEN:
{
    < DOUBLE_LITERAL: <DIGITS>
        | <DIGITS> ( "." <DIGITS> )?
        | "." <DIGITS>
    >
  | < FLOAT_LITERAL: <DIGITS> ( "f" | "F" )
        | <DIGITS> ( "." <DIGITS> ( "f" | "F" ) )?
        | "." <DIGITS> ( "f" | "F" )
    >
  | <DIGITS : (<DIGIT>)+ >
}

<DEFAULT>
TOKEN :
{
    <#LETTER : ["A" - "Z", "a" - "z"]>
  | <SPECIALCHARS : ["$", "_", "-"]>
}

<DEFAULT>
TOKEN :
{
    // backslash u + 4 hex digits escapes are handled in the underlying JavaCharStream
    <STRING_LITERAL : ("\"" (
          <EscapeQuot>
        | <EscapeBslash>
        | <EscapeSlash>
        | <EscapeBspace>
        | <EscapeFormf>
        | <EscapeNl>
        | <EscapeCr>
        | <EscapeTab>
        | ~["\"","\\"])* "\"")
      | ("\'"(
          <EscapeApos>
        | <EscapeBslash>
        | <EscapeSlash>
        | <EscapeBspace>
        | <EscapeFormf>
        | <EscapeNl>
        | <EscapeCr>
        | <EscapeTab>
        | ~["\'","\\"])* "\'")>
  | < #EscapeQuot: "\\\"" >
  | < #EscapeApos: "\\\'" >
  | < #EscapeBslash: "\\\\" >
  | < #EscapeSlash: "\\/" >
  | < #EscapeBspace: "\\b" >
  | < #EscapeFormf: "\\f" >
  | < #EscapeNl: "\\n" >
  | < #EscapeCr: "\\r" >
  | < #EscapeTab: "\\t" >
}

<DEFAULT>
TOKEN :
{
    <IDENTIFIER : <LETTER> (<LETTER> | <DIGIT> | <SPECIALCHARS>)*>
}

<DEFAULT>
TOKEN :
{
    <VARIABLE : "$" <LETTER> (<LETTER> | <DIGIT> | "_")*>
}

<DEFAULT>
SKIP:
{
    " "
  | "\t"
  | "\r"
  | "\n"
}

<DEFAULT>
SKIP:
{
    <"//" (~["\n"])* "\n">
}

<DEFAULT>
SKIP:
{
    <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")?> 
}

  
/**
 * Comments are ignored, nothing about what is inside comments is done.
 */
//<DEFAULT>
//SKIP:
//{
//    <"/*"> { pushState(); } : INSIDE_COMMENT
//}
//
//<INSIDE_COMMENT> SPECIAL : {
//<"+" (" ")* (~["*"])*>
//}
//
//   
//<INSIDE_COMMENT> SKIP : {
//"/*" : {
//}
//
//   
//<INSIDE_COMMENT> SKIP : {
//"*/" : {
//| <~[]>
//}

/**
 * Rules
 */
//TODO: Fix the multiple statement initiation.
List<AbstractStatement> Statements(): {
	List<AbstractStatement> statements = new ArrayList<AbstractStatement>();
	AbstractStatement statement;
}
{
	( statement = SingleStatement() 
		{
			statements.add(statement);
		} (";") ?
	)*
	<EOF>
	{
		return statements;  
	}
}

AbstractStatement SingleStatement(): {
	AbstractStatement stmt;
} {
	stmt = Query() { return stmt; }
}

SQLPPQuery Query(): { SQLPPQuery q = new SQLPPQuery(); AbstractExpression e;}
{
	e = SQLPPOperatorExpression() <EOF> 
	{
		q.setBody(e);
		return q;
	}
}

AbstractExpression SQLPPOperatorExpression() throws ParseException:
{
  SQLPPOperatorExpr op = null;
  AbstractExpression operand = null;
}
{
	operand = AndExpr()
	(
	  <OR>
  	{
  	  if (op == null) {
  	    op = new SQLPPOperatorExpr();
  	    op.addOperand(operand);      	     
  	  }  
      op.addOperator(token.image);
	}

	operand = AndExpr()
	{
	  op.addOperand(operand);
	}

	)*
	
	{
	  return op==null? operand: op;
	}
}

AbstractExpression AndExpr()throws ParseException:
{
  SQLPPOperatorExpr op = null;
  AbstractExpression operand = null;
}
{
	operand = RelExpr()
	(
	
	  <AND>
  	{
  	  if (op == null) {
  	    op = new SQLPPOperatorExpr();
  	    op.addOperand(operand);	      	     
  	  }  
      op.addOperator(token.image);
	}

	operand = RelExpr()
	{
	  op.addOperand(operand);
	}

	)*
	
	{
	  return op==null? operand: op;
	}
}



AbstractExpression RelExpr()throws ParseException:
{
  SQLPPOperatorExpr op = null;
  AbstractExpression operand = null;
}
{
    operand = AddExpr()

    (
      LOOKAHEAD(2)( <LT> | <GT> | <LE> | <GE> | <EQ> | <NE> |<SIMILAR>)
  	  {
  	    if (op == null) {
  	      op = new SQLPPOperatorExpr();
  	      op.addOperand(operand);
  	    }
        op.addOperator(token.image);
	  }
	  
 	  operand = AddExpr()
	  {
         op.addOperand(operand);
      } 
    )?
 	
 	{
 	  return op==null? operand: op;
 	}
}

AbstractExpression AddExpr() throws ParseException:
{
  SQLPPOperatorExpr op = null;
  AbstractExpression operand = null;  
}
{
	operand = MultExpr()

	( (<PLUS> | <MINUS>)
  	{
  	  if (op == null) {
  	    op = new SQLPPOperatorExpr();
        op.addOperand(operand);
  	  }
	  op.addOperator(token.image);
	}

	operand = MultExpr()
	{
	  op.addOperand(operand);
	}
	)*
	
	{
 	  return op==null? operand: op;
 	}
}

AbstractExpression MultExpr() throws ParseException:
{
  SQLPPOperatorExpr op = null;
  AbstractExpression operand = null;
}
{
	operand = UnaryExpr()

	(( <MUL> | <DIV> | <MOD> | <CARET> | <IDIV>)
  	{
  	  if (op == null) {
  	    op = new SQLPPOperatorExpr();
        op.addOperand(operand);          	    
  	  }
	  op.addOperator(token.image);
	}
	operand = UnaryExpr()
	{
	   op.addOperand(operand);
	}
	)*
	
 	{
 	  return op==null?operand:op;
 	}	
}

AbstractExpression UnaryExpr() throws ParseException:
{
	SQLPPUnaryExpr uexpr = null;
	AbstractExpression expr = null;
}
{
	( (<PLUS> | <MINUS>) 
	{
	  	uexpr = new SQLPPUnaryExpr();
		if("+".equals(token.image))
			uexpr.setSign(Sign.POSITIVE);
		else if("-".equals(token.image))
			uexpr.setSign(Sign.NEGATIVE);
		else 
			throw new ParseException();
	}
	)?
	
	expr = ValueExpr()
	{
		if(uexpr!=null){
			uexpr.setExpr(expr);
			return uexpr;
		}
		else{
			return expr;
		}
	}
}

AbstractExpression ValueExpr()throws ParseException:
{
  AbstractExpression expr = null;
}
{
    expr = Value()
    {
      return expr;
    }
}

AbstractExpression Value() throws ParseException:
{
  SQLPPValueExpression expr = new SQLPPValueExpression();
  String str = null;
}
{
  (
//    str = StringLiteral() //not sure how StringLiteral() works
//    {
//      expr.setValue(new StringValue(str));
//    }
	<STRING_LITERAL>
	{
	   expr.setValue(new StringValue(new String(token.image)));
	}
  |
	<INTEGER_LITERAL>
    {
    	try { 
    		expr.setValue(new IntegerValue(new Integer(token.image)));
    	} catch (NumberFormatException e) {
    		expr.setValue(new LongValue(new Long(token.image)));
    	}
    }
  | <FLOAT_LITERAL>
    {
    	expr.setValue(new FloatValue(new Integer(token.image)));
    }
  | <DOUBLE_LITERAL>
    {
    	expr.setValue(new DoubleValue(new Double(token.image)));
    }
  | <NULL>
    {
      	expr.setValue(new NullValue());
    }
  | <TRUE>
    {
	  	expr.setValue(new TrueValue());
    }      
  | <FALSE>
    {
      	expr.setValue(new FalseValue());
    }
  | <MISSING>
  	{
	  	expr.setValue(new MissingValue());
  	}
  )
    {
      return expr;
    }
}